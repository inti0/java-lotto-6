# 미션 - 로또

## 기능목록

### 입력
[x] (입력공통사항) 에러상황시 [ERROR]로 시작하는 에러문구를 출력하고 다시 입력받는다.
[x] 로또 구입 금액을 입력받는다.
 - [] 입력받은 금액을 로또의 개수로 변환한다.
 - [x] (예외사항) 숫자입력만 있는지, 지정된 범위(1000~100,000)가 넘어가는지, 1000원 이하의 금액이 있는지 확인한다. 
[x] 당첨 번호를 입력받는다.
 - [x] ","를 구분자로 한다.
 - [x] 각 숫자마다 앞뒤 공백은 제거하여 받는다.
 - [x] (예외사항) 숫자입력만 있는지, 지정된 범위(1~45)가 넘어가는지, 지정된 갯수(6)이 넘어가는지 확인한다.
[x] 보너스 번호를 입력받는다.
 - [x] (예외사항) 숫자입력만 있는지, 지정된 범위(1~45)가 넘어가는지, 지정된 갯수(1)이 넘어가는지 확인한다.
 - [x] (예외사항) 보너스번호는 당첨번호에서 고른 숫자와 중복되서는 안된다.

### 출력
[] 구입한 로또티켓 수를 출력한다.
[] 각 로또티켓마다 숫자 출력한다.
 - [] 오름차순으로, 대괄호를 양끝에 두고, ", "를 구분자로 한다.
[] 당첨내역을 출력한다.
 - [] 모든 등수에 대해 '3개 일치 (5,000원) - 1개' 와 같은 형식으로 출력한다.
 - [] 당첨 되지 않은 등수에 대해서도 출력한다.
[] 수익률을 출력한다.

### 모델
[x] 로또티켓 객체
[x] 번호 생성 객체는 번호 생성 인터페이스를 상속
[x] 로또티켓들을 갖는 Buyer
[x] 로또 결과들 Enum LottoResult

### 서비스
[x] 로또 티켓들을 갖고 Buyer 를 생성해주는 LottoShop
[x] 티켓들과 당첨번호들을 갖고 결과값을 생성해주는 LottoChecker
[x] 결과들을 갖고 수익률을 계산해주는 Calculator

### 컨트롤러
[] 세 번의 입력값을 받는 Input 객체를 구현

## 테스트
### 도메인 로직
로또티켓
[x] 로또티켓의 번호는 6개이다.
[x] 로또티켓의 각 숫자 범위는 1~45이다. 경계가 가장 의심되므로 1과 45에 대한 검증을 한다.

로또결과
[x] 각 로또티켓의 결과는 Enum 에 있는 것들 중 하나여야한다.
[x] 3개가 일치하면 5등, 4개가 일치하면 4등 ... 각각의 경우를 확인한다.

상금결과
[x] 소숫점 둘째자리에 반올림 한다. 즉, 반올림 기준점(0.05)에서 잘 되는지 확인해야한다.

입력
[] 각 입력은 숫자입력만 있는지, 지정된 범위가 넘어가는지, 지정된 갯수가 넘어가는지 확인한다.

출력
[] 각 출력은 문제 요구사항의 지정된 출력형식에 맞춰야한다.

-----------------------------------------------

##2주차 메일
클래스(객체)를 분리하는 연습
도메인 로직에 대한 단위 테스트를 작성하는 연습
도메인 로직과 단위 테스트와 같은 용어들이 낯설 수 있지만, 작은 기능부터 테스트를 작성하는 연습을 시작해 보는 것입니다. 
1주 차 피드백에서 제공된 숫자 야구 피드백 강의 후반부에 단위 테스트를 작성하는 내용이 있으니 이를 참고해 주세요.

과제를 제출할 때 이번 주 차 목표를 중심으로 학습하면서 느낀 점을 소감문으로 작성해 주세요.
이때 학습한 '과정’을 잘 드러내 주세요.

README.md를 상세히 작성한다
미션 저장소의 README.md는 소스코드에 앞서 해당 프로젝트가 어떠한 프로젝트인지 마크다운으로 작성하여 소개하는 문서이다. 
해당 프로젝트가 어떠한 프로젝트이며, 어떤 기능을 담고 있는지 기술하기 위해서 마크다운 문법을 검색해서 학습해 보고 적용해 본다.

기능 목록을 재검토한다
기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 너무 상세하게 작성하지 않는다.
클래스 이름, 함수(메서드) 시그니처와 반환값은 언제든지 변경될 수 있기 때문이다. 
너무 세세한 부분까지 정리하기보다 구현해야 할 기능 목록을 정리하는 데 집중한다. 
정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록에 정리한다.
특히 예외 상황은 시작 단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속해서 추가해 나간다.

기능 목록을 업데이트한다
README.md 파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다.
시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담을 가지기보다 기능을 구현하면서 문서를 계속 업데이트한다.
죽은 문서가 아니라 살아있는 문서를 만들기 위해 노력한다.

값을 하드 코딩하지 않는다
문자열, 숫자 등의 값을 하드 코딩하지 마라. 상수(static final)를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러내라.
구글에서 "java 상수"와 같은 키워드로 검색해 상수 구현 방법을 학습하고 적용해 본다.
구현 순서도 코딩 컨벤션이다
클래스는 상수, 멤버 변수, 생성자, 메서드 순으로 작성한다.

class A {
상수(static final) 또는 클래스 변수

    인스턴스 변수

    생성자

    메서드
}

변수 이름에 자료형은 사용하지 않는다
변수 이름에 자료형, 자료 구조 등을 사용하지 마라.
String carNameList = Console.readLine();
String[] arrayString = carNameList.split(",");

한 함수가 한 가지 기능만 담당하게 한다
함수 길이가 길어진다면 한 함수에서 여러 일을 하려고 하는 경우일 가능성이 높다.
아래와 같이 한 함수에서 안내 문구 출력, 사용자 입력, 유효값 검증 등 여러 일을 하고 있다면 이를 적절하게 분리한다.

함수가 한 가지 기능을 하는지 확인하는 기준을 세운다
만약 여러 함수에서 중복되어 사용되는 코드가 있다면 함수 분리를 고민해 본다.
또한, 함수의 길이를 15라인을 넘어가지 않도록 구현하며 함수를 분리하는 의식적인 연습을 할 수 있다.
테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다
단지 기능을 점검하기 위한 목적으로 테스트를 작성하는 것은 아니다.
테스트를 작성하는 과정을 통해서 나의 코드에 대해 빠르게 피드백을 받을 수 있을 뿐만 아니라
학습 도구로도 활용할 수 있다. 이런 경험을 통해 테스트에 대해 어떤 유용함을 느꼈는지 알아본다.
처음부터 큰 단위의 테스트를 만들지 않는다
테스트의 중요한 목적 중 하나는 내가 작성하는 코드에 대해 빠르게 피드백을 받는 것이다.
시작부터 큰 단위의 테스트를 만들게 된다면 작성한 코드에 대한 피드백을 받기까지 많은 시간이 걸린다.
그래서 문제를 작게 나누고, 그 중 핵심 기능에 가까운 부분부터 작게 테스트를 만들어 나간다.


